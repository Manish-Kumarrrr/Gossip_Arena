{"ast":null,"code":"const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\nfunction decodeComponents(components, split) {\n  try {\n    // Try to decode the entire string first\n    return [decodeURIComponent(components.join(''))];\n  } catch {\n    // Do nothing\n  }\n  if (components.length === 1) {\n    return components;\n  }\n  split = split || 1;\n\n  // Split the array in 2 parts\n  const left = components.slice(0, split);\n  const right = components.slice(split);\n  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input);\n  } catch {\n    let tokens = input.match(singleMatcher) || [];\n    for (let i = 1; i < tokens.length; i++) {\n      input = decodeComponents(tokens, i).join('');\n      tokens = input.match(singleMatcher) || [];\n    }\n    return input;\n  }\n}\nfunction customDecodeURIComponent(input) {\n  // Keep track of all the replacements and prefill the map with the `BOM`\n  const replaceMap = {\n    '%FE%FF': '\\uFFFD\\uFFFD',\n    '%FF%FE': '\\uFFFD\\uFFFD'\n  };\n  let match = multiMatcher.exec(input);\n  while (match) {\n    try {\n      // Decode as big chunks as possible\n      replaceMap[match[0]] = decodeURIComponent(match[0]);\n    } catch {\n      const result = decode(match[0]);\n      if (result !== match[0]) {\n        replaceMap[match[0]] = result;\n      }\n    }\n    match = multiMatcher.exec(input);\n  }\n\n  // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n  replaceMap['%C2'] = '\\uFFFD';\n  const entries = Object.keys(replaceMap);\n  for (const key of entries) {\n    // Replace all decoded components\n    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  }\n  return input;\n}\nexport default function decodeUriComponent(encodedURI) {\n  if (typeof encodedURI !== 'string') {\n    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  }\n  try {\n    // Try the built in decoder first\n    return decodeURIComponent(encodedURI);\n  } catch {\n    // Fallback to a more advanced decoder\n    return customDecodeURIComponent(encodedURI);\n  }\n}","map":{"version":3,"names":["token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","length","left","slice","right","Array","prototype","concat","call","decode","input","tokens","match","i","customDecodeURIComponent","replaceMap","exec","result","entries","Object","keys","key","replace","decodeUriComponent","encodedURI","TypeError"],"sources":["C:/Users/manis/OneDrive/Desktop/Gossip_Arena/client/node_modules/decode-uri-component/index.js"],"sourcesContent":["const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn [decodeURIComponent(components.join(''))];\n\t} catch {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tconst left = components.slice(0, split);\n\tconst right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch {\n\t\tlet tokens = input.match(singleMatcher) || [];\n\n\t\tfor (let i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher) || [];\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tconst replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD',\n\t};\n\n\tlet match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch {\n\t\t\tconst result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tconst entries = Object.keys(replaceMap);\n\n\tfor (const key of entries) {\n\t\t// Replace all decoded components\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nexport default function decodeUriComponent(encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}